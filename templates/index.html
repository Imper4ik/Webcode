<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>–£—á–µ–±–Ω—ã–µ –∑–∞–¥–∞–Ω–∏—è</title>
  <link rel="stylesheet" href="/static/style.css">
</head>
<body>
  <header>
    <h1>–£—á–µ–±–Ω—ã–µ –∑–∞–¥–∞–Ω–∏—è</h1>
    <p class="muted">–í—ã–±–∏—Ä–∞–π –≥–ª–∞–≤—É, –∏–∑—É—á–∞–π —Ç–µ–æ—Ä–∏—é –ø–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É –º–µ—Ç–æ–¥—É –∏ —Ä–µ—à–∞–π —Å–≤—è–∑–∞–Ω–Ω—ã–µ –∑–∞–¥–∞–Ω–∏—è –≤ —Ä–µ–¥–∞–∫—Ç–æ—Ä–µ.</p>
    <nav id="chapterTabs" class="chapter-tabs"></nav>
  </header>

  <main>
    <div class="layout">
      <aside class="panel methods-panel">
        <div class="panel-header">
          <h2 id="methodsPanelTitle">–ì–ª–∞–≤—ã</h2>
          <p id="chapterLead" class="muted small">–í—ã–±–µ—Ä–∏—Ç–µ –≥–ª–∞–≤—É, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å —Å–ø–∏—Å–æ–∫ –º–µ—Ç–æ–¥–æ–≤.</p>
        </div>
        <div id="methodsList" class="methods-list"></div>
      </aside>

      <section class="panel method-panel">
        <div class="method-header">
          <h2 id="methodTitle">–ú–µ—Ç–æ–¥ –Ω–µ –≤—ã–±—Ä–∞–Ω</h2>
          <p id="methodSummary" class="small">–í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Ç–æ–¥ –∏–∑ —Å–ø–∏—Å–∫–∞ —Å–ª–µ–≤–∞.</p>
        </div>

        <section class="method-section">
          <h3>–¢–µ–æ—Ä–∏—è</h3>
          <div id="methodTheory" class="theory-text muted">–ü–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ –º–µ—Ç–æ–¥–∞ –∑–¥–µ—Å—å –ø–æ—è–≤–∏—Ç—Å—è –∫—Ä–∞—Ç–∫–∏–π –∫–æ–Ω—Å–ø–µ–∫—Ç.</div>
        </section>

        <section class="method-section">
          <h3>–ó–∞–¥–∞—á–∏</h3>
          <p id="methodTaskHint" class="muted small">–í—ã–±–µ—Ä–∏—Ç–µ –∑–∞–¥–∞—á—É, —á—Ç–æ–±—ã –∑–∞–≥—Ä—É–∑–∏—Ç—å –µ—ë –æ–ø–∏—Å–∞–Ω–∏–µ –∏ —Å—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥ –≤ —Ä–µ–¥–∞–∫—Ç–æ—Ä.</p>
          <ul id="methodTasksList" class="method-tasks-list empty">
            <li class="placeholder">–°–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–µ–Ω –ø–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ –º–µ—Ç–æ–¥–∞.</li>
          </ul>
        </section>

        <section class="method-section editor-section">
          <h3>–†–µ–¥–∞–∫—Ç–æ—Ä</h3>
          <p id="taskSelectedLabel" class="muted small">–ó–∞–¥–∞—á–∞ –Ω–µ –≤—ã–±—Ä–∞–Ω–∞.</p>
          <pre id="taskDesc" class="desc"></pre>
          <textarea id="code" placeholder="–í—Å—Ç–∞–≤—å –∏–ª–∏ –ø—Ä–∞–≤—å —Å—Ç–∞—Ä—Ç–æ–≤—ã–π –∫–æ–¥"></textarea>
          <div class="row">
            <button id="run">–ó–∞–ø—É—Å—Ç–∏—Ç—å —Ç–µ—Å—Ç—ã</button>
            <button id="hint">–ü–æ–¥—Å–∫–∞–∑–∫–∞</button>
          </div>
          <pre id="output" class="log"></pre>
        </section>
      </section>
    </div>
  </main>

<script>
async function fetchTask(taskName){
  const r = await fetch('/api/task/' + encodeURIComponent(taskName));
  if(!r.ok) throw new Error('unknown task');
  return r.json();
}

async function fetchCatalog(){
  const r = await fetch('/api/chapters');
  if(!r.ok) throw new Error('network');
  return r.json();
}

const state = {
  chapters: [],
  completed: new Set(),
  selectedChapter: null,
  selectedMethod: null,
  currentTask: null,
  chapterButtons: new Map(),
  methodButtons: new Map(),
  taskButtons: new Map()
};

function setMutedText(el, text, muted = false){
  if(!el) return;
  el.textContent = text;
  el.classList.toggle('muted', muted);
}

function getSelectedChapter(){
  if(!state.selectedChapter) return null;
  return state.chapters.find(ch => ch.name === state.selectedChapter) || null;
}

function getSelectedMethod(){
  const chapter = getSelectedChapter();
  if(!chapter || !state.selectedMethod) return null;
  return chapter.methods.find(m => m.name === state.selectedMethod) || null;
}

function renderChapterTabs(){
  const nav = document.getElementById('chapterTabs');
  nav.innerHTML = '';
  state.chapterButtons.clear();
  if(!state.chapters.length){
    const span = document.createElement('span');
    span.className = 'placeholder';
    span.textContent = '–ì–ª–∞–≤—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.';
    nav.appendChild(span);
    return;
  }
  state.chapters.forEach(chapter => {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'tab-button';
    btn.textContent = chapter.title;
    if(chapter.name === state.selectedChapter){
      btn.classList.add('active');
    }
    btn.addEventListener('click', () => {
      if(state.selectedChapter === chapter.name) return;
      selectChapter(chapter.name);
    });
    nav.appendChild(btn);
    state.chapterButtons.set(chapter.name, btn);
  });
}

function renderMethodsList(){
  const container = document.getElementById('methodsList');
  const lead = document.getElementById('chapterLead');
  const title = document.getElementById('methodsPanelTitle');
  container.innerHTML = '';
  state.methodButtons.clear();
  const chapter = getSelectedChapter();
  if(!chapter){
    title.textContent = '–ì–ª–∞–≤—ã';
    setMutedText(lead, '–í—ã–±–µ—Ä–∏—Ç–µ –≥–ª–∞–≤—É, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å —Å–ø–∏—Å–æ–∫ –º–µ—Ç–æ–¥–æ–≤.', true);
    const placeholder = document.createElement('div');
    placeholder.className = 'placeholder';
    placeholder.textContent = '–ù–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–π –≥–ª–∞–≤—ã.';
    container.appendChild(placeholder);
    return;
  }
  title.textContent = chapter.title;
  setMutedText(lead, chapter.theory || '–í —ç—Ç–æ–π –≥–ª–∞–≤–µ –ø–æ–∫–∞ –Ω–µ—Ç —Ç–µ–æ—Ä–∏–∏.', !chapter.theory);
  if(!chapter.methods.length){
    const placeholder = document.createElement('div');
    placeholder.className = 'placeholder';
    placeholder.textContent = '–î–ª—è –≥–ª–∞–≤—ã –ø–æ–∫–∞ –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω—ã –º–µ—Ç–æ–¥—ã.';
    container.appendChild(placeholder);
    return;
  }
  chapter.methods.forEach(method => {
    const button = document.createElement('button');
    button.type = 'button';
    button.className = 'method-item';
    const completedCount = method.tasks.filter(t => state.completed.has(t)).length;
    const total = method.tasks.length;
    const status = total === 0
      ? 'üìò'
      : completedCount === total
        ? '‚úÖ'
        : completedCount > 0
          ? 'üü°'
          : '‚¨ú';
    button.innerHTML = `
      <span class="method-status">${status}</span>
      <span class="method-text">
        <span class="method-name">${method.title}</span>
        ${method.summary ? `<span class="method-summary">${method.summary}</span>` : ''}
      </span>`;
    if(method.name === state.selectedMethod){
      button.classList.add('active');
    }
    button.addEventListener('click', () => {
      if(state.selectedMethod === method.name) return;
      selectMethod(method.name);
    });
    container.appendChild(button);
    state.methodButtons.set(method.name, button);
  });
}

function renderTaskList(tasks){
  const list = document.getElementById('methodTasksList');
  list.innerHTML = '';
  state.taskButtons.clear();
  if(!tasks || !tasks.length){
    list.classList.add('empty');
    const li = document.createElement('li');
    li.className = 'placeholder';
    li.textContent = '–î–ª—è –º–µ—Ç–æ–¥–∞ –ø–æ–∫–∞ –Ω–µ—Ç –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏—Ö –∑–∞–¥–∞–Ω–∏–π.';
    list.appendChild(li);
    return;
  }
  list.classList.remove('empty');
  tasks.forEach(taskName => {
    const li = document.createElement('li');
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'task-item';
    const done = state.completed.has(taskName);
    btn.innerHTML = `
      <span class="task-status">${done ? '‚úÖ' : '‚¨ú'}</span>
      <span class="task-name">${taskName}</span>`;
    if(taskName === state.currentTask){
      btn.classList.add('active');
    }
    btn.addEventListener('click', () => {
      if(state.currentTask === taskName) return;
      selectTask(taskName, {resetOutput: true});
    });
    li.appendChild(btn);
    list.appendChild(li);
    state.taskButtons.set(taskName, btn);
  });
}

function updateMethodPanel({autoSelectTask = true} = {}){
  const method = getSelectedMethod();
  const titleEl = document.getElementById('methodTitle');
  const summaryEl = document.getElementById('methodSummary');
  const theoryEl = document.getElementById('methodTheory');
  const taskHint = document.getElementById('methodTaskHint');
  if(!method){
    titleEl.textContent = '–ú–µ—Ç–æ–¥ –Ω–µ –≤—ã–±—Ä–∞–Ω';
    setMutedText(summaryEl, '–í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Ç–æ–¥ –∏–∑ —Å–ø–∏—Å–∫–∞ —Å–ª–µ–≤–∞.', true);
    setMutedText(theoryEl, '–ü–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ –º–µ—Ç–æ–¥–∞ –∑–¥–µ—Å—å –ø–æ—è–≤–∏—Ç—Å—è –∫—Ä–∞—Ç–∫–∏–π –∫–æ–Ω—Å–ø–µ–∫—Ç.', true);
    renderTaskList([]);
    if(autoSelectTask){
      selectTask(null, {resetOutput: true, suppressFetch: true});
    }
    return;
  }
  titleEl.textContent = method.title;
  const summaryText = orDefault(method.summary || '', '–î–ª—è –º–µ—Ç–æ–¥–∞ –ø–æ–∫–∞ –Ω–µ—Ç –∫—Ä–∞—Ç–∫–æ–≥–æ –æ–ø–∏—Å–∞–Ω–∏—è.');
  setMutedText(summaryEl, summaryText, !(method.summary && method.summary.trim()));
  const theoryText = (method.theory || '').trim();
  setMutedText(
    theoryEl,
    theoryText || '–¢–µ–æ—Ä–∏—è –¥–ª—è –º–µ—Ç–æ–¥–∞ –ø–æ–∫–∞ –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω–∞.',
    !theoryText
  );
  taskHint.classList.toggle('hidden', method.tasks.length === 0);
  renderTaskList(method.tasks);
  if(!method.tasks.length){
    if(autoSelectTask){
      selectTask(null, {resetOutput: false, suppressFetch: true});
    }
    return;
  }
  if(!autoSelectTask){
    highlightSelection();
    return;
  }
  let targetTask = state.currentTask;
  if(!targetTask || !method.tasks.includes(targetTask)){
    targetTask = method.tasks.find(task => !state.completed.has(task)) || method.tasks[0];
  }
  if(state.currentTask === targetTask){
    highlightSelection();
    return;
  }
  selectTask(targetTask, {resetOutput: false});
}

function orDefault(value, fallback){
  return value && value.trim() ? value : fallback;
}

function highlightSelection(){
  state.chapterButtons.forEach((btn, name) => {
    btn.classList.toggle('active', name === state.selectedChapter);
  });
  state.methodButtons.forEach((btn, name) => {
    btn.classList.toggle('active', name === state.selectedMethod);
  });
  state.taskButtons.forEach((btn, name) => {
    btn.classList.toggle('active', name === state.currentTask);
  });
}

async function selectChapter(chapterName){
  const chapterExists = state.chapters.some(ch => ch.name === chapterName);
  if(!chapterExists) return;
  const sameChapter = state.selectedChapter === chapterName;
  state.selectedChapter = chapterName;
  state.selectedMethod = sameChapter ? state.selectedMethod : null;
  renderChapterTabs();
  renderMethodsList();
  const chapter = getSelectedChapter();
  if(!chapter){
    updateMethodPanel();
    highlightSelection();
    return;
  }
  if(!chapter.methods.length){
    state.selectedMethod = null;
    updateMethodPanel();
    highlightSelection();
    return;
  }
  if(!state.selectedMethod || !chapter.methods.some(m => m.name === state.selectedMethod)){
    state.selectedMethod = chapter.methods[0].name;
  }
  renderMethodsList();
  updateMethodPanel();
  highlightSelection();
}

function selectMethod(methodName){
  const chapter = getSelectedChapter();
  if(!chapter || !chapter.methods.some(m => m.name === methodName)) return;
  state.selectedMethod = methodName;
  renderMethodsList();
  updateMethodPanel();
  highlightSelection();
}

async function selectTask(taskName, {resetOutput = false, suppressFetch = false} = {}){
  state.currentTask = taskName;
  highlightSelection();
  const label = document.getElementById('taskSelectedLabel');
  const desc = document.getElementById('taskDesc');
  const code = document.getElementById('code');
  if(!taskName){
    setMutedText(label, '–ó–∞–¥–∞—á–∞ –Ω–µ –≤—ã–±—Ä–∞–Ω–∞.', true);
    desc.textContent = '';
    code.value = '';
    if(resetOutput){
      document.getElementById('output').textContent = '';
    }
    return;
  }
  label.textContent = `–í—ã–±—Ä–∞–Ω–∞ –∑–∞–¥–∞—á–∞: ${taskName}`;
  try{
    if(!suppressFetch){
      const task = await fetchTask(taskName);
      desc.textContent = task.description || '';
      code.value = task.starter_code || '';
    }
    if(resetOutput){
      document.getElementById('output').textContent = '';
    }
  }catch(err){
    desc.textContent = '–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏.';
    code.value = '';
  }
}

async function loadCatalog(preserveSelection = true){
  const previousChapter = preserveSelection ? state.selectedChapter : null;
  const previousMethod = preserveSelection ? state.selectedMethod : null;
  const previousTask = preserveSelection ? state.currentTask : null;
  const data = await fetchCatalog();
  state.chapters = data.chapters || [];
  state.completed = new Set(data.completed || []);
  state.chapterButtons.clear();
  state.methodButtons.clear();
  state.taskButtons.clear();
  let targetChapter = previousChapter && state.chapters.some(ch => ch.name === previousChapter)
    ? previousChapter
    : (state.chapters[0] ? state.chapters[0].name : null);
  state.selectedChapter = targetChapter;
  renderChapterTabs();
  renderMethodsList();
  if(!targetChapter){
    updateMethodPanel();
    highlightSelection();
    return;
  }
  const chapter = getSelectedChapter();
  if(chapter && chapter.methods.length){
    let targetMethod = previousMethod && chapter.methods.some(m => m.name === previousMethod)
      ? previousMethod
      : chapter.methods[0].name;
    state.selectedMethod = targetMethod;
    const method = getSelectedMethod();
    renderMethodsList();
    updateMethodPanel({autoSelectTask: false});
    if(method){
      let targetTask = previousTask && method.tasks.includes(previousTask)
        ? previousTask
        : (method.tasks.find(t => !state.completed.has(t)) || method.tasks[0]);
      await selectTask(targetTask, {resetOutput: false});
    }
  } else {
    state.selectedMethod = null;
    updateMethodPanel();
  }
  highlightSelection();
}

function setupActions(){
  document.getElementById('run').addEventListener('click', async () => {
    const out = document.getElementById('output');
    if(!state.currentTask){
      out.textContent = '–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –∑–∞–¥–∞—á—É.';
      return;
    }
    out.textContent = '–ó–∞–ø—É—Å–∫...';
    const code = document.getElementById('code').value;
    const r = await fetch('/run_code', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({code, task: state.currentTask})
    });
    const data = await r.json();
    if((data.stdout || '').includes('OK')){
      out.textContent = '–¢–µ—Å—Ç—ã –ø—Ä–æ–π–¥–µ–Ω—ã ‚úÖ\n' + (data.stdout || '');
      await fetch('/complete_task', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({username: 'user1', task: state.currentTask})
      });
      await loadCatalog(true);
    } else {
      const details =
        data.details ||
        data.stderr ||
        data.compile_output ||
        data.message ||
        data.status ||
        data.stdout;
      out.textContent = '–ü—Ä–æ–≤–∞–ª–µ–Ω–æ ‚ùå\n' + (typeof details === 'string' ? details : JSON.stringify(details, null, 2));
    }
  });

  document.getElementById('hint').addEventListener('click', async (ev) => {
    const btn = ev.currentTarget;
    if(btn.disabled) return;
    btn.disabled = true;
    const out = document.getElementById('output');
    const prev = out.textContent;
    const code = document.getElementById('code').value;
    const desc = document.getElementById('taskDesc').textContent;
    out.textContent = (prev ? prev + '\n\n' : '') + '–ó–∞–ø—Ä–∞—à–∏–≤–∞—é –ø–æ–¥—Å–∫–∞–∑–∫—É...';
    try{
      const r = await fetch('/api/get-hint', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({code, description: desc})
      });
      const data = await r.json();
      if(data.hint){
        out.textContent = (prev ? prev + '\n\n' : '') + '–ü–æ–¥—Å–∫–∞–∑–∫–∞: ' + data.hint + (data.cached ? ' (–∏–∑ –∫—ç—à–∞)' : '');
      } else if(data.error === 'rate_limited'){
        out.textContent = (prev ? prev + '\n\n' : '') + '–°–ª–∏—à–∫–æ–º —á–∞—Å—Ç–æ. –ü–æ–ø—Ä–æ–±—É–π —á—É—Ç—å –ø–æ–∑–∂–µ.';
      } else {
        out.textContent = (prev ? prev + '\n\n' : '') + '–û—à–∏–±–∫–∞: ' + (data.details ? JSON.stringify(data.details) : '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ');
      }
    } finally {
      setTimeout(() => { btn.disabled = false; }, 1200);
    }
  });
}

(async () => {
  setupActions();
  await loadCatalog(true);
})();
</script>
</body>
</html>
